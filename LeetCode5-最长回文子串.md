# LeetCode5-最长回文子串

## 一、题目描述

给你一个字符串 s，找到 s 中最长的回文子串。

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"
示例 3：

输入：s = "a"
输出："a"
示例 4：

输入：s = "ac"
输出："a"


提示：

1 <= s.length <= 1000
s 仅由数字和英文字母（大写和/或小写）组成

## 二、解法

子串：原始字符串的一个**连续子集**

子序列：原始字符串的一个子集

### 方法一：中心扩散法

（1）方法描述：

①核心思想：由中心字符向两边同时扩散，寻找回文子串（根据判断条件，逐步扩大回文串在原字符串中的范围）

枚举所有可能的回文子串的中心位置，并根据选定的中心位置向两边扩散寻找中心确定的回文子串。

注：中心位置可能是一个字符（字符个数为奇数的回文串），也有可能是两个相邻的字符（字符个数为偶数的回文串）。

②枚举回文中心：

ⅰ回文中心：回文串中中间位置上的元素

ⅱ特点：回文中心必须是回文串（单个字符可以认为是长度为1的回文串）

字符个数为奇数的回文串：回文中心的字符为最中间的一个字符（整个回文串关于该字符对称），该字符的位置为：(回文串长度+1)/2

字符个数为偶数的回文串：回文中心的字符为最中间的两个字符（整个回文串关于这两个字符的中心位置对称），且这两个字符必须相同，这两个字符的位置分别为：回文串长度/2 和 回文串长度/2+1

回文中心的数量：长度为n的字符串的奇数回文中心有n个，偶数回文中心有（n-1）个，总共有（2*n-1）个回文中心。

ⅲ边界条件：回文中心的位置在[0,s.size()-1]之间，即回文串的中心在字符串中

ⅳ 处理：遍历字符串中每一个位置上的字符，将该字符分别当做奇数回文串和偶数回文串的中心，并通过回文中心扩展操作，分别得到扩展后的奇数回文串和偶数回文串。比较奇数回文串和偶数回文串的长度，保留那个长度较长的回文子串为以该字符为中心的回文子串。

③扩散指定回文中心所在的回文串：

ⅰ 已知条件：处理的字符串、给定的回文中心（回文中心的下标）

ⅱ 扩散的条件：当前回文中心左右两边的字符相等时，向两边扩展回文中心。

ⅲ 结束条件：当前回文中心左右两边的字符不满足扩散的条件。

ⅳ 返回值：最后的回文子串的长度

④最长回文子串：由于在处理过程中用下标暂时标记回文子串的起始位置，在枚举不同回文中心及其相对应的回文子串的过程中，会根据长度大小比较获取到所有回文中心对应的回文子串中长度最长的回文子串的起始下标。

更新回文子串的条件：当前得到的回文子串的长度大于原回文子串的长度

⑤子串的截取：寻找回文串的过程中，只标记下标，记录回文子串开始和结束的位置（对应字符在原字符串中的下标），最后再调用函数截取子串。

⑥边界条件：对字符串为空的情况单独处理

空字符串（长度为0）：最长回文子串为空

长度为1的字符串：最长回文子串为它本身

长度大于等于2的字符串：需要通过特定方法在原字符串中查找其最长的回文子串

（2）具体描述：

```
class Solution {
public:
    string longestPalindrome(string s) //寻找指定字符串的最长回文子串
    {
        if(s.length() < 1)//特殊情况处理，字符串为空时，直接返回空
        {
            return "";
        }
        int start=0;//定义最长回文子串的开始位置
        int end=0;//定义最长回文子串的结束位置
        for(int i=0;i<s.length();i++)//枚举政整个字符串的所有回文中心
        {
            int L1=FindPalindromeCenter(s,i,i);//计算以s[i]为回文中心得到的奇数回文串的长度
            int L2=FindPalindromeCenter(s,i,i+1);//计算以s[i]和s[i+1]为回文中心得到的偶数回文串的长度
            int L=max(L1,L2);//当前回文中心的长度为以该字符为回文中心的奇数回文串和偶数回文串中的较大者
            if(L>end-start+1)//判断当前得到的回文子串长度与原回文子串长度的大小，当前得到的回文子串长度较大时，则更新回文子串的位置
            {
            /*当回文子串的长度为L,回文中心为i时，回文中心左边的长度为（L-1）/2，则开始位置=i-（L-1）/2,回文中心右边的长度为（L-1）/2，则结束位置=i+（L-1）/2
            当回文子串的长度为L,回文中心为i和（i+1）时，回文中心左边的长度为（L-2）/2=(（L-1）/2)向下取整，则开始位置=i-（L-2）/2,回文中心右边的长度为（L-2）/2，则结束位置=i+1+（L-2）/2=i+L/2
            当回文中心相同时（都包含s[i]），偶数回文子串的长度比奇数回文子串的长度多1.所以当L为偶数时，（L-2）/2=(（L-1）/2)向下取整
            综合上述两种情况，回文串的开始位置=i-(L-1)/2，结合位置=i+L/2*/
                 start=i-(L-1)/2;//回文子串的开始位置
                 end=i+L/2;//回文子串的结束位置
            }
        }
        return s.substr(start,end-start+1);//返回找到的回文子串
        /*substr()函数为C++中string模板库中截取指定子串的方法
        字符串名称.substr(截取的子串的起始位置，截取的子串的长度)函数*/
    }
    int FindPalindromeCenter(string str,int left,int right)//寻找指定中心的回文串
    {
        while(left>=0 && right<str.length() && str[left]==str[right])//当回文串的中心仍在字符串中时，如果当前回文中心左右两边的字符相等，则扩展回文串
        {
            left--;//左边界向左扩展
            right++;//右边界向右扩展
        }
        return right-left-1;//返回得到的回文串的长度，因为上述边界s[0]和s[s.size()-1]也包含在内，满足条件时left=-1，right=s.size()，所以字符串的长度为(right-left-1)
    }
};

```

```

//优化版本，用更高效的方式存储得到的回文子串
class Solution {
public:
    pair<int, int> expandAroundCenter(const string& s, int left, int right) //获取由指定中心扩展后的回文串的长度
    {
        while (left >= 0 && right < s.size() && s[left] == s[right])//更新回文串的左右边界
        {
            --left;
            ++right;
        }
        return {left + 1, right - 1};//以键值的形式返回回文子串
        /*由于更新回文串时的条件中包含了对边界的判断以及更新，所以得到的回文串的左右边界位置时真正的回文串的两边，所以要对左边界进行加1操作，对右边界进行减1操作*/
    }
    string longestPalindrome(string s) //获取字符串的最长回文子串
    {
        int start = 0;//定义最长回文子串的起始位置
        intend = 0;//定义最长回文子串的结束位置
        for (int i = 0; i < s.size(); ++i)//枚举回文中心
         {
            auto [left1, right1] = expandAroundCenter(s, i, i);//获取以字符s[i]为中心的奇数回文串的位置参数
            auto [left2, right2] = expandAroundCenter(s, i, i + 1);//获取以字符s[i]为中心的偶数回文串的位置参数
            if (right1 - left1 > end - start)//判断奇数回文串的长度与原回文串的长度关系
             {
                start = left1;//满足条件时，更新最长回文子串的位置参数
                end = right1;
            }
            if (right2 - left2 > end - start) //判断偶数回文串的长度与原回文串的长度关系
            {
                start = left2;//满足条件时，更新最长回文子串的位置参数
                end = right2;
            }
        }
        return s.substr(start, end - start + 1);//返回截取的最长回文子串

    }
};
/*知识点补充：C++中的auto
auto是c++程序设计语言的关键字。用于两种情况

（1）声明变量时根据初始化表达式自动推断该变量的类型

（2）声明函数时函数返回值的占位符
优点：
（1）用于在初始化表达式中声明复杂类型变量声明以简化代码。
（2）可以避免类型声明时的错误（运算时的溢出问题）。

*/
```

（3）运行结果：

![image-20220103164456019](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220103164456019.png)

### 方法二：动态规划法

（1）方法描述:

①基本思想：自上而下分解问题，自下而上得到结果

以贪心法的思想，在局部最优的情况下求解全局最优的结果。------->对于一个子串来说，如果它是回文串，并且长度大于2，那么将它首尾的两个字符去除之后，它仍然是个回文串。

由于长度为1的字符串默认为一个回文串，所以将在字符串中求解最长回文子串的问题拆解为求解较小回文子串的问题。通过存储子问题的结果以减少多次重复计算某一相同子问题带来的时间开销。

②边界条件：

ⅰ说明：用P(i,j)表示字符串s的第i个字符到第j个字符构成的子串

当P(i,j)=true时，表示字符串s中s[i]到s[j]构成的子串为回文串；

当P(i,j)=false时，表示字符串s中s[i]到s[j]构成的子串不是回文串或者s[i]到s[j]构成的字符串不合法。

ⅱ空字符串：返回空

ⅲ长度为1的字符串：该字符串即为回文串P*(*i*,*i)=true

ⅳ长度为2的字符串：只要两个字符相同，该字符串为回文串P*(*i,i+1)=(S[i]==S[i]+1)

③初始化操作：所有长度为1的子串都是回文串

④回文串的判断：对于长度大于2的子串，通过对其子串是否为回文串的进行判断。如果该子串去掉左右边界（左边界加1，右边界减1）后得到其子串为回文串且左右边界的字符相同，则该子串为回文串。

当s[i]!=s[j]时，一定不是回文子串；

当s[i]=s[j]时，需要分情况讨论：

​     情况1：下标i与j相同，则指向同一字符，是回文串

​     情况2：下标i与j相差1,且是j-i=1，也是回文串

​      情况3：下标i与j相差大于1,需要判断该子串该子串左右边界后的子串是否是回文串

P(i,j)=P(i+1,j−1)∧(S[i]==S[j])

条件：s[i+1,j-1]为回文串且是s[i]=s[j]

⑤递推关系：由长度较短的回文串判断长度较长的字符串是否是回文串

状态：dp [i] [j]表示子串s[i..j]是否为回文子串

状态转移方程：dp [i] [j] = ((s[i] == s[j]) and dp [i+1] [j-1] )

边界条件：子串长度=（j-1)-(i+1)+1=j-i-1<2，即 j-i<3

⑥输出：当得到一个状态值为true的子串时，记录起始位置和长度，完成n*n（n为字符串的长度）的表格中枚举的每个长度的子串是否为回文串的长度的判断

例：字符串“babab”

| 字符 | b    | a    | b    | a    | b    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 下标 | 0    | 1    | 2    | 3    | 4    |

状态转移方程：dp [i] [j] = ((s[i] == s[j]) and (j-i<3)  or dp [i+1] [j-1] )

填表顺序：先列后行（先从上到下，再从左到右）

| 边界（左边界，右边界） | 0    | 1     | 2     | 3     | 4     |
| ---------------------: | ---- | ----- | ----- | ----- | ----- |
|                      0 | true | false | true  | false | true  |
|                      1 |      | true  | flase | true  | false |
|                      2 |      |       | true  | false | true  |
|                      3 |      |       |       | true  | false |
|                      4 |      |       |       |       | true  |

（2）具体实现：

```
class Solution {
public:
    string longestPalindrome(string s) 
    {
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));//声明一个大小为s.size()*s.size()的整型二维数组用于存储由该字符串构成的所有的子串的状态，标识该子串是否是回文串，并初始化dp[i][j]为false
        int maxlenth = 0;//定义最长回文子串的长度，并初始化为0
        int left = 0;//定义标识回文子串的左边界位置
        int right = 0;//定义标识回文子串的右边界位置
        for (int i = s.size() - 1; i >= 0; i--)//填表,先列后行（先从下到上，再从左到右）
         {
            for (int j = i; j < s.size(); j++) 
            {
                if (s[i] == s[j]) 
                {
                    if (j - i <= 1) 
                    { // 情况一 和 情况二
                        dp[i][j] = true;//长度为1和2的情况
                    } 
                    else if (dp[i + 1][j - 1]) 
                    { // 情况三
                        dp[i][j] = true;//长度>2的情况
                    }
                }
                if (dp[i][j] && j - i + 1 > maxlenth)//更新最长回文子串，条件为该子串为回文串且长度大于原回文串
                 {
                    maxlenth = j - i + 1;//计算回文串的长度
                    left = i;//更新回文串左边界的位置
                    right = j;//更新回文串右边界的位置
                }
            }

        }
        return s.substr(left, right - left + 1);//返回截取的回文子串
    }
};
```

```
class Solution {
public:
    string longestPalindrome(string s)
    {
        int n=s.size();
        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));//创建于字符串等大小的二维数组用于保存每种每个子串是否是回文串的判断结果
        int maxlength=0;//记录最长回文子串的长度
        int left=0;//记录最长回文子串的左边界位置
        int right=0;//记录最长回文子串的右边界的位置
        for(int i=n-1;i>=0;i--)//计算每个子串是否是回文串
        {
            for(int j=i;j<n;j++)
            {
                if(i==j)//对角线上的元素，长度为1的子串为回文串
                {
                    dp[i][j]=true;
                }
                else if(s[i]==s[j])//其他情况需要对i和j所对应的字符进行判断，只有两个字符相同才有可能是回文串
                {
                    if(j-i==1)//s[i]和s[j]之间无其他元素时，只要s[i]=s[j]时，该长度为2的字符串的回文串
                        dp[i][j]=true;
                    else if(dp[i+1][j-1]==true)//s[i]和s[j]之间有其他元素时，只有当中间的子串是回文串时，只要s[i]=s[j]时，该子串是回文串
                        dp[i][j]=true;
                }
                if(dp[i][j]==true && (j-i+1)>maxlength)//将当前子串与当前最长回文串的长度进行比较，并保留长度较大者作为新的最长回文子串
                {
                     left=i;
                     right=j;
                     maxlength=j-i+1;
                }
            }  
        }
        return s.substr(left,maxlength);//调用C++中的函数substr截取原字符串中从第一个参数位置开始，连续的第二个参数的子串作为结果返回
    }
};
```

（3）运行结果：

![image-20220103221943690](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220103221943690.png)

