# LeetCode7-整数反转

## 题目描述

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。


示例 1：

输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21
示例 4：

输入：x = 0
输出：0


提示：

2的31次方的相反数 <= x <= 2的31次方减1

## 解题

### 相关知识点

1、取余运算与取模运算

对于整型数a、b来说，取余和取模的运算方法一样，都为：

（1）求整数商：c=a/b

（2）取余和取模：r=a-c*b

两种运算的区别在于：

取余运算在取c值时，向0方向舍入；取模运算在计算c值时，向负无穷方向舍入。

```
例如：a=-7,b=4

取余时：c=-1(向0方向舍入)，r=3,即余数为3

取模时：c=-2(向负无穷方向舍入)，r=1,即模为1
```

归纳为：

（1）当a和b符号一致时，求模运算和求余运算所得的c的值是一致的，因此结果一致

（2）当a和b符号不一致时，求模运算结果的符号和b一致，求余运算结果的符号和a一致

注：在各种语言中%运算符的含义：C/C++，Java为取余，Python为取模

### 题解

#### 方法一：直接比较法

（1）方法描述

①基本思想：边反转边判断溢出

由于反转结果可能会溢出，所以需要在反转时判断是否溢出。

②反转实现：动态获取每一位作为最低有效位的数值，即可得到原数值每一位的数值

ⅰ 具体操作：从原数值的最低有效位按位进行，所以下一次的反转结果需要将上一次的反转结果作为高位的值（即乘以10），然后再加上这一次得到的某一位上的数值。

ⅱ 取每一位的值：对原数值取余再除以10，可以得到原数值从最低有效位到最高有效位上的每一位的数值。

ⅲ 求反转结果 ：对反转结果依次乘以10在加上得到的该位上的数值即可得到最终的反转结果。

③溢出判断：

溢出的条件时：反转结果大于整数的最大值 或 小于整数的最小值

反转过程中的溢出判断：由于反转的实现是从原数值的最低有效位按位进行，所以下一次的反转结果需要将上一次的反转结果作为高位的值（即乘以10），然后再加上这一次得到的某一位上的数值，所以每次反转开始前需要通过当前反转结果与最值除以10的结果的比较进行判断

④返回结果：

如果在反转过程中发生了溢出，则返回0

如果在反转过程中未发生溢出，则返回反转结果（反转结果中包含正负）

（由于c++中的取余操作区分正负，所以不需要对原数值的正负情况单独考虑。）

（2）具体实现

```
//正确运行
class Solution {
public:
    int reverse(int x) 
    {
        int ReverseNumber=0;//初始化反转结果为0
        while(x!=0)//对原数值进行逐位反转操作直到某一位的数值为0
        {
           //先对上一次反转得到的结果进行溢出判断，再进行本次的反转操作
           if(ReverseNumber < INT_MIN/10 || ReverseNumber > INT_MAX/10)//溢出判断，反转结果小于最小值除以10向下取整的值或者大于最大值除以10向下取整的值，则判断发生了溢出
            {
                return 0;
            }
            int digit=x%10;//对10取余得到x最低有效位的值
            x/=10;//除以10消除刚才得到的数值的那一位
            ReverseNumber=ReverseNumber*10+digit;//每得到一位的值，则得到对应的反转结果(将上一次的反转结果作为高位值----乘以10实现，再加上得到的该位上的值)
        }
        return ReverseNumber;//返回反转结果，返回0的情况已在反转时考虑
    }
};
```



```
//溢出错误
class Solution {
public:
    int reverse(int x) 
    {
        int ReverseNumber=0;
        while(x!=0)//对原数值x进行反转
        {
            int digit=x%10;
            x/=10;
            ReverseNumber=ReverseNumber*10+digit;
        }
        if(ReverseNumber < INT_MIN || ReverseNumber > INT_MAX)//对反转后的结果进行判断
        {
            return 0;
        }
        return ReverseNumber;
    }
};
```

原因分析：由于声明的保存反转结果的变量为int类型（32位），反转过程中得到的结果如果溢出的话，则不会保存，所以虽然执行结果正确，但是提交后会提示有溢出错误。（个人猜测的原因）

（3）运行结果

![image-20220115191228044](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220115191228044.png)

#### 方法二：间接判断法

（1）方法描述

①基本思想：按位拆解整数，按照位权组装整数，边界比较判断溢出

利用权重的思想实现32位有符号整数的反转，通过整数长度和反转后最高位值与整数最大值和最小值的比较判断是否发生溢出。

②溢出判断：

32位有符号整数的最小值：INT_MIN=负的2的31次方=-2147483648

32位有符号整数的最大值：INT_MAX=2的31次方减1=2147483847

观察两个最值可知：两个最值均为10位整数且最高位的数值均为2

溢出条件： 长度等于10且反转结果超过最值

判断条件：

​     ⅰ 反转后的最高有效位的值（即原数值最低有效位的值）>  最值绝对值的最高有效位的值（即2） ，并且原数值的长度等于10

​    ⅱ  反转后的最高有效位的值（即原数值最低有效位的值）=  最值绝对值的最高有效位的值（即2） ，并且剩余部分的数值 >最值绝对值的除最高有效位外剩余部分的值（即147483648） 

③反转实现：

ⅰ为了方便进行数值部分的比较，将原数值转化为非负数实现反转。

ⅱ 为保证反转结果结果的顺利实现，将输入的数值的最低位剔除（即忽略反转结果的最高位），保证反转后的结果的长度小于10位，不会发生溢出，便于后续溢出的判断

ⅲ 由于原数值的最高有效位为反转结果的最低有效位，最低有效位为反转结果的最高有效位，所以利用栈结构先进后出的特点，将原数值通过取余运算和除法运算得到的从最低有效位到最高有效位的每个位上的数值依次存入栈中，然后再依次出栈并赋予相应的权值，即可得到反转结果。

ⅳ 每位数值--->反转结果：给从栈中依次取出的数值赋予相应的权值，并加上低位数值，即可得到反转结果。（由于处于栈顶的为原数值的高位，是反转结果的低位，所以从栈顶到栈底的每个数值对应位的权值依次增大。）

④返回值： 

ⅰ由于反转过程中对原数值取了绝对值，且正数和负数的边界不同，所以需要对正数和负数单独进行判断。

ⅱ利用栈逆转和位权求和得到的反转结果时剔除最高有效位后的结果，所以最终的结果还要加上最高位的值

（2）具体实现

```
class Solution {
public:
    int reverse(int x) 
    {
        if(x==-2147483648)//正负数的范围不对对称，为便于后续直接对绝对值的处理（按照正数的情况处理），对负数的边界情况进行单独判断
        {
            return 0;
        }
        int value=fabs(x);//调用C++中的库函数对原数值取绝对值
        int MSB=value%10;//提出原数值的最低有效位单独处理
        value=value/10;//得到提出最低有效位后的结果
        stack<int> bitdata;//创建数据类型为整型的栈，保存原数值中除最低有效位外的其他位上的数值
        while(value!=0)//当value的值不为0时，依次通过对10取余的操作得到每位上的数值，并通过除以10操作剔除已经得到的位的影响
        {
            bitdata.push(value%10);//将得到的对应位上的数值存入栈中
            value=value/10;
        }
        int MSB_value=pow(10,bitdata.size());//计算反转后最高有效位的权值
        int length=bitdata.size()+1;//计算反转结果的长度
        int reverseNumber=0;//初始化反转结果为0
        int weight=1;//初始化权重为1
        while(!bitdata.empty())//按位加权求和
        {
            int reverseBit=bitdata.top();//保存栈顶元素
            bitdata.pop();//栈顶元素出栈
            reverseNumber=reverseNumber+reverseBit*weight;//求反转结果，当前的反转结果为上一次的反转结果（低位数值）加上改为上的数值与相应权值的乘积
            weight=weight*10;//由于反转的求和从最低位开始，所以权值依次增大为原来的10倍，
        }
        if(x<0)//原数值为负数
        {
            if((MSB > 2 && length==10) || (MSB==2 && reverseNumber > 147483647))//溢出判断
            {
                return 0;
            }
            else
            {
                return -(reverseNumber+MSB*MSB_value);//未溢出时，返回结果为反转结果加上最高位数值的相反数
            }
        }
        else//原数值为非负数
        {
            if((MSB > 2 && length==10) || (MSB==2 && reverseNumber >= 147483647))//溢出判断
            {
                return 0;
            }
            else
            {
                return reverseNumber+MSB*MSB_value;//未溢出时，返回结果为反转结果与最高位数值的求和结果
            }
        }
    }
};
```

（3）运行结果

![image-20220115155238641](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220115155238641.png)

